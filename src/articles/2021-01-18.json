{
  "id": 6,
  "title": "AVR ATmega328p のエミュレータを Rust で実装する",
  "created_at": "2021-01-18T00:00:00.000Z",
  "updated_at": "2021-01-18T00:00:00.000Z",
  "draft": false,
  "tags": "Rust,AVR,CPU Emulator",
  "bodyContent": "",
  "bodyHtml": [
    "<div class=\"Box-body readme blob js-code-block-container p-5 p-xl-6 gist-border-0\" id=\"readme\">",
    "<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><p>電子工作を気軽に楽しめる <a href=\"https://www.arduino.cc/\" rel=\"nofollow\">Arduino</a> というマイコンボードをご存知でしょうか。",
    "ボードとパーツを用意して Arduino 言語でプログラミングをすることで、",
    "初心者でも簡単にセンサーの制御やモーターの駆動などを楽しめるようにした人気のプラットフォームです。</p>",
    "<p>今回はその Arduino のマイコンとして採用されている Atmel AVR マイクロコントローラの",
    "エミュレータを Rust で実装した話を書いてみます。</p>",
    "<p>AVR マイコンは非常に多機能で、最終的には<strong>マイコンのエミュレータ</strong>を完全な形で実装することは",
    "難しいと気付いたのですが、その過程の中で最低限動作するエミュレータができました。",
    "Rust で実装する CPU エミュレータに興味がある方、Arduino の CPU の詳細に興味がある方",
    "の参考になれば幸いです。</p>",
    "<p>ソースコードは<a href=\"https://github.com/kazukiyoshida/avr-emulator\">こちら</a>に公開しています。<br/>",
    "言語は Rust 1.46、動作環境は macOS Catalina 10.15.7 です。</p>",
    "<p><a href=\"https://github.com/kazukiyoshida/nuxt-blog/blob/master/src/assets/images/20210118/avr1.png\" rel=\"noopener noreferrer\" target=\"_blank\"><img alt=\"avr1\" src=\"https://github.com/kazukiyoshida/nuxt-blog/raw/master/src/assets/images/20210118/avr1.png\" style=\"max-width:100%;\"/></a></p>",
    "<h2><a aria-hidden=\"true\" class=\"anchor\" href=\"#avr-マイコンとは\" id=\"user-content-avr-マイコンとは\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>AVR マイコンとは</h2>",
    "<p>AVR はアトメル社が開発し、現在は Microchip社が製造・販売している RISC ベース 8bit",
    "マイクロコントローラです。CPU、メモリ、IOポート、クロック発振回路、タイマーなどが",
    "1チップに収められています。一般的な CPU で採用されているノイマン・アーキテクチャとは異なり、",
    "プログラムを記憶するメモリとデータを記憶するメモリを別とするハーバード・アーキテクチャを採用していて、",
    "これによって1クロック1インストラクションの高速な動作を実現しています。</p>",
    "<p>物理的なチップに加えて、AVR マイコンの動作をシミュレーションするツールも Microchip 社から",
    "公式に提供されています。以前は Atmel Studio という名前でしたが、2021年現在は",
    "<a href=\"https://www.microchip.com/en-us/development-tools-tools-and-software/microchip-studio-for-avr-and-sam-devices\" rel=\"nofollow\">Microchip Studio</a>",
    "という名称になっています。このシミュレータを使うことでアセンブラ単位での実行やメモリの",
    "値を確認することができ、今回はこれを正としてエミュレータを実装しました。</p>",
    "<h2><a aria-hidden=\"true\" class=\"anchor\" href=\"#avr-atmega328p-とは\" id=\"user-content-avr-atmega328p-とは\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>AVR ATmega328P とは</h2>",
    "<p>AVR はピン数やメモリサイズの異なる幅広い製品ラインを揃えていますが、Arduino が採用している",
    "のは ATmega328P というチップです。ATmega328P の特徴を挙げてみると以下のようになります。</p>",
    "<ul>",
    "<li>動作速度 20MHz（動作電圧 5V のとき）</li>",
    "<li>32KB のフラッシュメモリと 2KB の内臓 SRAM</li>",
    "<li>2つの 8bit タイマ、1つの 16bit タイマ（それぞれ PWM 付き）</li>",
    "<li>幅広いシリアルインターフェイス（SPI、USART、I2C、USI）</li>",
    "<li>ADコンバータ、アナログ・コンパレータ</li>",
    "</ul>",
    "<h2><a aria-hidden=\"true\" class=\"anchor\" href=\"#avr-エミュレータの実装目標\" id=\"user-content-avr-エミュレータの実装目標\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>AVR エミュレータの実装目標</h2>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#当初の目標\" id=\"user-content-当初の目標\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>当初の目標</h3>",
    "<p>プロジェクトを立ち上げた当初は私の勉強不足のために実装する機能を小さく見積もっていました。",
    "AVR の命令セットといくつかの周辺機能をデータシート通りに実装するだけと考えていたのですが、",
    "実際に取り掛かってみるとタイマやIOポートの詳細な仕様を把握するのにも苦労しました。</p>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#つくったもの\" id=\"user-content-つくったもの\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>つくったもの</h3>",
    "<p>当初の予定通りとはいきませんでしたが、CPU の基本的な機能と IO ポート、タイマに",
    "ついては最低限動作するものになりました。成果物をまとめると次のようになります。</p>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#基本構成\" id=\"user-content-基本構成\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>基本構成</h4>",
    "<ul>",
    "<li>AVR 命令セットの約半分（63 / 130 命令）</li>",
    "<li>32個のレジスタファイル、SRAM、FlashMemory</li>",
    "<li>8bit x 2個 、16bit x 1個 の PWM 付きタイマ（4つの動作モードを含む）</li>",
    "<li>IO ポートとピンの入出力</li>",
    "</ul>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#エミュレータにプログラムする実行ファイル\" id=\"user-content-エミュレータにプログラムする実行ファイル\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>エミュレータにプログラムする実行ファイル</h4>",
    "<ul>",
    "<li>Atmel Studio でコンパイルした Lチカ のプログラム</li>",
    "</ul>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#実装したアプリケーション\" id=\"user-content-実装したアプリケーション\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>実装したアプリケーション</h4>",
    "<ul>",
    "<li>デバッグ用に 1命令 ずつ実行していくもの（step_by_step.rs）</li>",
    "<li>連続してクロックを動作させることでプログラムを実行するもの（flow.rs）</li>",
    "<li>上記を WebAssembly として実行させるもの</li>",
    "</ul>",
    "<p>step_by_step.rs を実行すると画像のように Program Counter や",
    "レジスタなどの状況を逐一確認しながら進めることができます。</p>",
    "<p><a href=\"https://github.com/kazukiyoshida/nuxt-blog/blob/master/src/assets/images/20210118/emulator.gif\" rel=\"noopener noreferrer\" target=\"_blank\"><img alt=\"step_by_step 実行イメージ\" src=\"https://github.com/kazukiyoshida/nuxt-blog/raw/master/src/assets/images/20210118/emulator.gif\" style=\"max-width:100%;\" title=\"step_by_step 実行イメージ\"/></a></p>",
    "<h2><a aria-hidden=\"true\" class=\"anchor\" href=\"#avr-エミュレータを作ろう\" id=\"user-content-avr-エミュレータを作ろう\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>AVR エミュレータを作ろう</h2>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#a-メモリ\" id=\"user-content-a-メモリ\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>A. メモリ</h3>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#flashmemory\" id=\"user-content-flashmemory\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>FlashMemory</h4>",
    "<p>AVR の FlashMemory は 16 bit のシンプルな線形メモリで、ここにブートローダやプログラムが書き込まれます。",
    "今回はこれを u16 のベクタで表現します。固定長の配列<code>[u16; N]</code>で表現することも",
    "できますが、ATmega328P のメモリサイズに限定したくなかったのでベクタを使っています。</p>",
    "<p>メモリに必要な機能としては、値を読み出す関数 、値をセットする関数 、",
    "HEXファイルを書き込む（プログラムする）関数、などが必要となるので実装します。</p>",
    "<p>Intel HEX の仕様については<a href=\"https://ja.wikipedia.org/wiki/Intel_HEX\" rel=\"nofollow\">Wikipedia</a>が詳しいです。",
    "レコードタイプがデータとなっている行に16進数でプログラムが並んでいるので、",
    "1word（16bit）にあたる4文字を取得して、リトルエンディアンでメモリに展開しています。",
    "つまり HEX ファイルで \"...ABCD...\" というデータがあれば、FlashMemory の1アドレスには \"CDAB\" と書き込まれます。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">struct</span> <span class=\"pl-en\">FlashMemory</span> {",
    "    data: <span class=\"pl-k\">Vec</span><span class=\"pl-k\">&lt;</span><span class=\"pl-k\">u16</span><span class=\"pl-k\">&gt;</span>,",
    "}",
    "",
    "<span class=\"pl-k\">impl</span> <span class=\"pl-en\">FlashMemory</span> {",
    "    <span class=\"pl-c\">// 番地を指定して値を読み出す</span>",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">get</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>, a: <span class=\"pl-k\">usize</span>) -&gt; <span class=\"pl-k\">u16</span> { <span class=\"pl-c1\">self</span>.data[a] }",
    "",
    "    <span class=\"pl-c\">// 番地を指定して値を更新する</span>",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">set</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>, a: <span class=\"pl-k\">usize</span>, v: <span class=\"pl-k\">u16</span>) { <span class=\"pl-c1\">self</span>.data[a] <span class=\"pl-k\">=</span> v; }",
    "",
    "    <span class=\"pl-c\">// Intel HEX 形式の実行ファイルに相当する文字列からプログラムをメモリに展開する</span>",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">load_hex_from_string</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>, hex: <span class=\"pl-k\">String</span>) { ..  }",
    "}</pre></div>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#sram\" id=\"user-content-sram\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>SRAM</h4>",
    "<p>AVR のデータ・メモリ・スペースは 8bit で構成されています。",
    "今回はレジスタファイル、I/Oレジスタ、内部SRAM をまとめて SRAM として宣言しました。",
    "そのため 0x00 ~ 0x1f 番地（0 ~ 31）がレジスタファイル、0x20 ~ 0x5f 番地（32 ~ 96）",
    "が I/Oレジスタとなっています。</p>",
    "<p>AVR のレジスタ名称は共通化されている（SREG、SPH、SPL など）のですが、",
    "具体的なメモリ番地は製品のデータシートを読む必要があります。",
    "今回は ATmega328P に特化させず、一般的な AVR マイコンに対応した SRAM として実装したかったので、",
    "このレジスタマップは後から設定できるようにしました。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">struct</span> <span class=\"pl-en\">SRAM</span> {",
    "    data: <span class=\"pl-k\">Vec</span><span class=\"pl-k\">&lt;</span><span class=\"pl-k\">u8</span><span class=\"pl-k\">&gt;</span>,",
    "    <span class=\"pl-k\">pub</span> map: &amp;<span class=\"pl-k\">'<span class=\"pl-en\">static</span></span> RegisterMap,            <span class=\"pl-c\">// レジスタマップを設定できるようにテーブルを用意</span>",
    "    <span class=\"pl-k\">pub</span> word_map: &amp;<span class=\"pl-k\">'<span class=\"pl-en\">static</span></span> RegisterWordMap,   <span class=\"pl-c\">// 1word 単位でのレジスタマップの設定テーブル</span>",
    "    <span class=\"pl-k\">pub</span> bit_map: &amp;<span class=\"pl-k\">'<span class=\"pl-en\">static</span></span> RegisterBitMap,     <span class=\"pl-c\">// 1bit 単位でのレジスタマップの設定テーブル</span>",
    "}",
    "",
    "<span class=\"pl-c\">// レジスタマップを設定するためのテーブル</span>",
    "<span class=\"pl-k\">struct</span> <span class=\"pl-en\">RegisterMap</span> {",
    "    sreg: <span class=\"pl-k\">usize</span>,  <span class=\"pl-c\">// ステータス・レジスタの番地</span>",
    "    sph: <span class=\"pl-k\">usize</span>,   <span class=\"pl-c\">// Stack Pointer High</span>",
    "    spl: <span class=\"pl-k\">usize</span>,   <span class=\"pl-c\">// Stack Pointer Low</span>",
    "    portd: <span class=\"pl-k\">usize</span>, <span class=\"pl-c\">// ポートD の PORTx レジスタ</span>",
    "    ddrd: <span class=\"pl-k\">usize</span>,  <span class=\"pl-c\">// ポートD の データ・ディレクション・レジスタ</span>",
    "    pind: <span class=\"pl-k\">usize</span>,  <span class=\"pl-c\">// ポートD の PINx レジスタ</span>",
    "    ..            <span class=\"pl-c\">// 他にもたくさん..</span>",
    "}</pre></div>",
    "<p>上記のように RegisterMap は繰り返しの記述が多くなったので、独自のマクロで定義を簡素化しました。",
    "下のマクロを実行すると、上で記述した RegisterMap の宣言が展開されます。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-c\">// 定型的な構造体の宣言を簡素化する独自マクロ</span>",
    "<span class=\"pl-en\">define_stationary_struct!</span>(",
    "    RegisterMap,   <span class=\"pl-c\">// 定義したい構造体の名前</span>",
    "    <span class=\"pl-k\">usize</span>,         <span class=\"pl-c\">// 値の型</span>",
    "    sreg, sph, spl, portd, ddrd, pind, ucsr0a, ucsr0b, ucsr0c,              <span class=\"pl-c\">// 構造体のキー（レジスタの名前）を列挙</span>",
    "    portc, ddrc, pinc, portb, ddrb, pinb, ramend, mcusr, twsr, twar, twdr,",
    "    ...",
    ");</pre></div>",
    "<p>プログラムが実行されると SRAM の RAMEND から 0x0000 に向けてスタックが伸びていきます。",
    "スタック・ポインタを取得する関数やスタックの push・pop を実行する関数なども用意します。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">impl</span> <span class=\"pl-en\">SRAM</span> {",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">sp</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>) -&gt; <span class=\"pl-k\">u16</span> { .. }",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">push_stack</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>, v: <span class=\"pl-k\">u8</span>) { .. }",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">pop_stack</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>) -&gt; <span class=\"pl-k\">u8</span> { .. }",
    "}</pre></div>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#b-cpu本体\" id=\"user-content-b-cpu本体\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>B. CPU本体</h3>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#avrマイコン-トレイト\" id=\"user-content-avrマイコン-トレイト\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>AVRマイコン トレイト</h4>",
    "<p>今回は ATmega328P の実装しかできませんでしたが、当初は AVR マイコンの一般的な実装を行いたかったので",
    "AVR マイコンとしての振る舞いをトレイトとして用意しました。用意した機能は、(1) プログラムの書き込み、",
    "(2) CPUの初期化、(3, 4) IO ポートの読み書き、です。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">trait</span> <span class=\"pl-en\">AVRMCU</span> {",
    "    <span class=\"pl-c\">// HEX 形式のプログラムを FlashMemory に書き込む</span>",
    "    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">program</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>, hex: <span class=\"pl-k\">String</span>);",
    "",
    "    <span class=\"pl-c\">// PC, SP, SREG など CPU のステータスを初期化する</span>",
    "    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">initialize</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>);",
    "",
    "    <span class=\"pl-c\">// IO ポートの値を読み取る</span>",
    "    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">get_pins</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>) -&gt; <span class=\"pl-k\">Vec</span>&lt;<span class=\"pl-k\">bool</span>&gt;;",
    "",
    "    <span class=\"pl-c\">// IO ポートに値を入力する</span>",
    "    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">set_pins</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>, pins: <span class=\"pl-k\">Vec</span>&lt;<span class=\"pl-k\">bool</span>&gt;);",
    "}</pre></div>",
    "<p>今回はクロックを進める振る舞いは AVRMCU トレイトには含めず、代わりに Iterator トレイトを実装する方針としました。",
    "これについては ATmega328P の実装の際に見ていきます。</p>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#atmega328p\" id=\"user-content-atmega328p\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>ATmega328P</h4>",
    "<p>ATmega328P の具体的な実装に入ります。ATmega328P のコアは FlashMemory、SRAM に",
    "加えて、Program Counter（PC）、現在のサイクル数、次回実行予定のインストラクション",
    "を保持する構造体として定義しました。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">struct</span> <span class=\"pl-en\">ATmega328P</span> {",
    "    pc: <span class=\"pl-k\">usize</span>,                              <span class=\"pl-c\">// Program Counter</span>",
    "    cycle: <span class=\"pl-k\">u64</span>,                             <span class=\"pl-c\">// 実行サイクル数</span>",
    "    instr: <span class=\"pl-k\">Option</span><span class=\"pl-k\">&lt;</span>Instr<span class=\"pl-k\">&gt;</span>,                   <span class=\"pl-c\">// （次の）命令</span>",
    "    instr_func: <span class=\"pl-k\">Option</span><span class=\"pl-k\">&lt;</span>InstrFunc<span class=\"pl-k\">&gt;</span>,          <span class=\"pl-c\">// （次の）命令に対応する関数</span>",
    "    sram: Rc<span class=\"pl-k\">&lt;</span>RefCell<span class=\"pl-k\">&lt;</span>SRAM<span class=\"pl-k\">&gt;&gt;</span>,                <span class=\"pl-c\">// SRAM</span>",
    "    flash_memory: Rc<span class=\"pl-k\">&lt;</span>RefCell<span class=\"pl-k\">&lt;</span>FlashMemory<span class=\"pl-k\">&gt;&gt;</span>, <span class=\"pl-c\">// FlashMemory</span>",
    "}</pre></div>",
    "<p>また前述の通り SRAM は AVR に一般的な実装としているので、ATmega328P の実装の際に",
    "そのレジスタマップを<a href=\"https://avr.jp/user/DS/PDF/mega328P.pdf\" rel=\"nofollow\">データシート</a>通りに宣言していきます。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">const</span> REGISTER_MAP: RegisterMap <span class=\"pl-k\">=</span> RegisterMap {",
    "    sreg: <span class=\"pl-c1\">0x5f</span>,",
    "    sph: <span class=\"pl-c1\">0x5e</span>,",
    "    spl: <span class=\"pl-c1\">0x5d</span>,",
    "",
    "    <span class=\"pl-c\">// Timer 0 (8-bit)</span>",
    "    tcnt0: <span class=\"pl-c1\">0x46</span>,",
    "    tccr0a: <span class=\"pl-c1\">0x44</span>,",
    "    ...",
    "}</pre></div>",
    "<p>ATmega328P には Iterator を実装し、next 関数をコールすることでインストラクション",
    "が実行されるようにしました。PC が示す 1word から、AVR インストラクションをデコードする",
    "必要がありますが、これを実現するために後述する命令セットツリー<code>OPCODE_TREE</code>を用いています。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-k\">impl</span> <span class=\"pl-c1\">Iterator</span> <span class=\"pl-k\">for</span> <span class=\"pl-en\">ATmega328P</span> {",
    "    <span class=\"pl-k\">type</span> <span class=\"pl-en\">Item</span> = ();",
    "",
    "    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">next</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>) -&gt; <span class=\"pl-k\">Option</span>&lt;()&gt; {",
    "        <span class=\"pl-c\">// *** インストラクションの実行</span>",
    "        <span class=\"pl-k\">let</span> (next_pc, next_cycle) <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.instr_func.<span class=\"pl-en\">unwrap</span>()(",
    "            <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>.sram.<span class=\"pl-en\">borrow_mut</span>(),",
    "            <span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>.flash_memory.<span class=\"pl-en\">borrow</span>(),",
    "            <span class=\"pl-c1\">self</span>.pc,",
    "            <span class=\"pl-c1\">self</span>.cycle,",
    "        );",
    "",
    "        <span class=\"pl-c\">// *** 次のインストラクションに向けた準備</span>",
    "        <span class=\"pl-c1\">self</span>.pc <span class=\"pl-k\">=</span> next_pc;       <span class=\"pl-c\">// PC を再設定</span>",
    "        <span class=\"pl-c1\">self</span>.cycle <span class=\"pl-k\">=</span> next_cycle; <span class=\"pl-c\">// サイクル数も更新</span>",
    "",
    "        <span class=\"pl-c\">// FlashMemory から PC が示す 1word のプログラムを取得</span>",
    "        <span class=\"pl-k\">let</span> word <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.flash_memory.<span class=\"pl-en\">borrow</span>().<span class=\"pl-en\">get</span>(<span class=\"pl-c1\">self</span>.pc <span class=\"pl-k\">as</span> <span class=\"pl-k\">usize</span>);",
    "",
    "        <span class=\"pl-c\">// 取得した 1word がどの AVR インストラクションに対応するのか検索する</span>",
    "        <span class=\"pl-k\">let</span> (instr, instr_func) <span class=\"pl-k\">=</span> OPCODE_TREE.<span class=\"pl-en\">with</span>(<span class=\"pl-k\">|</span>tree<span class=\"pl-k\">|</span> tree.<span class=\"pl-en\">find</span>(word));",
    "        <span class=\"pl-c1\">self</span>.instr <span class=\"pl-k\">=</span> <span class=\"pl-c1\">Some</span>(instr);",
    "        <span class=\"pl-c1\">self</span>.instr_func <span class=\"pl-k\">=</span> <span class=\"pl-c1\">Some</span>(instr_func);",
    "",
    "        <span class=\"pl-c1\">Some</span>(())",
    "    }",
    "}</pre></div>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#c-命令セット\" id=\"user-content-c-命令セット\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>C. 命令セット</h3>",
    "<p>AVR 命令セットは全130命令ありますが、そのうち半分程度を実装しました。",
    "各命令に対応した関数 InstrFunc を用意し、これがメモリを更新したり、",
    "次回の Program Counter とサイクル数を返すようにしています。</p>",
    "<p>今回は FlashMemory, SRAM としてトレイトオブジェクトを使用して動的ディスパッチをさせていますが、",
    "これは ATmega328P 以外の実装を増やしていった場合にエミュレータの実行バイナリが肥大化",
    "するのを防ぐためでした。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-c\">// 命令セット Enum</span>",
    "<span class=\"pl-k\">pub</span> <span class=\"pl-k\">enum</span> <span class=\"pl-en\">Instr</span> {",
    "    ADD, ADC, ADIW, SUB, SBC, SUBI, SBCI, SBIW, DEC, COM, LD1, LD2, LD3, LDI,",
    "    LDDY1, LDDY2, LDDY3, LDDZ1, LDDZ2, LDDZ3, LDS, OUT, IN, NOP, CALL, RCALL,",
    "    ...",
    "}",
    "",
    "<span class=\"pl-c\">// インストラクション関数の型</span>",
    "<span class=\"pl-k\">pub</span> <span class=\"pl-k\">type</span> <span class=\"pl-en\">InstrFunc</span> = &amp;<span class=\"pl-k\">'<span class=\"pl-en\">static</span></span> <span class=\"pl-k\">dyn</span> <span class=\"pl-c1\">Fn</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> SRAM, <span class=\"pl-k\">&amp;</span>FlashMemory, <span class=\"pl-k\">usize</span>, <span class=\"pl-k\">u64</span>) -&gt; (<span class=\"pl-k\">usize</span>, <span class=\"pl-k\">u64</span>);",
    "",
    "<span class=\"pl-c\">// ADD 命令のインストラクション関数</span>",
    "<span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">add</span>(sram: <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> SRAM, flash_memory: <span class=\"pl-k\">&amp;</span>FlashMemory, pc: <span class=\"pl-k\">usize</span>, cycle: <span class=\"pl-k\">u64</span>) -&gt; (<span class=\"pl-k\">usize</span>, <span class=\"pl-k\">u64</span>) {",
    "    <span class=\"pl-k\">let</span> (r_addr, d_addr) <span class=\"pl-k\">=</span> flash_memory.<span class=\"pl-en\">word</span>(pc).<span class=\"pl-en\">operand55</span>();",
    "    <span class=\"pl-k\">let</span> (r, d) <span class=\"pl-k\">=</span> sram.<span class=\"pl-en\">gets</span>(r_addr, d_addr);",
    "    <span class=\"pl-k\">let</span> res <span class=\"pl-k\">=</span> r.<span class=\"pl-en\">wrapping_add</span>(d);",
    "    sram.<span class=\"pl-en\">set</span>(d_addr, res);",
    "    sram.<span class=\"pl-en\">set_status_by_arithmetic_instruction</span>(d, r, res);",
    "    sram.<span class=\"pl-en\">set_bit</span>(sram.bit_map.c, <span class=\"pl-en\">has_borrow_from_msb</span>(r, d, res));",
    "    (pc <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>, cycle <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)",
    "}</pre></div>",
    "<p>PC が示す 1word のプログラムから AVR インストラクションをデコードするために、",
    "オペコードと命令セットのツリー OPCODE_TREE を構築しています。",
    "検索したい 1word の命令のビット列の左端から見ていき、ツリーを辿っていくと命令にたどり着くようになっています。</p>",
    "<p>OPCODE_TREE は AVR 命令のアドレッシングモードも考慮する必要があります。",
    "<a href=\"http://ww1.microchip.com/downloads/en/devicedoc/atmel-0856-avr-instruction-set-manual.pdf\" rel=\"nofollow\">AVR Instruction Set Manual</a>",
    "を見ると、例えば ADD 命令は</p>",
    "<ul>",
    "<li><code>0000_11rd_dddd_rrrr</code></li>",
    "</ul>",
    "<p>と定義されています。この場合、先頭 6bit がオペコードとなるのでこれを</p>",
    "<ul>",
    "<li><code>1111_1100_0000_0000</code>（マスク）</li>",
    "<li><code>0000_1100_0000_0000</code>（オペコード）</li>",
    "</ul>",
    "<p>のペアとして表現しています。",
    "ツリーはアプリケーション起動時に static なデータとして構築しています。",
    "（lazy_static で定義せず thread local に宣言している理由は失念してしまいました...すみません...）</p>",
    "<div class=\"highlight highlight-source-rust\"><pre><span class=\"pl-en\">thread_local!</span> {",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">static</span> OPCODE_TREE: Node <span class=\"pl-k\">=</span> {",
    "        <span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> t: Node <span class=\"pl-k\">=</span> <span class=\"pl-c1\">Default</span><span class=\"pl-k\">::</span><span class=\"pl-en\">default</span>();",
    "        t.<span class=\"pl-en\">add</span>((<span class=\"pl-c1\">0b0000_1100_0000_0000</span>, <span class=\"pl-c1\">0b1111_1100_0000_0000</span>), Instr<span class=\"pl-k\">::</span>ADD, <span class=\"pl-k\">&amp;</span>add);",
    "        t.<span class=\"pl-en\">add</span>((<span class=\"pl-c1\">0b0001_1100_0000_0000</span>, <span class=\"pl-c1\">0b1111_1100_0000_0000</span>), Instr<span class=\"pl-k\">::</span>ADC, <span class=\"pl-k\">&amp;</span>adc);",
    "        t.<span class=\"pl-en\">add</span>((<span class=\"pl-c1\">0b1001_0110_0000_0000</span>, <span class=\"pl-c1\">0b1111_1111_0000_0000</span>), Instr<span class=\"pl-k\">::</span>ADIW, <span class=\"pl-k\">&amp;</span>adiw);",
    "        t.<span class=\"pl-en\">add</span>((<span class=\"pl-c1\">0b0001_1000_0000_0000</span>, <span class=\"pl-c1\">0b1111_1100_0000_0000</span>), Instr<span class=\"pl-k\">::</span>SUB, <span class=\"pl-k\">&amp;</span>sub);</pre></div>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#d-周辺機能\" id=\"user-content-d-周辺機能\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>D. 周辺機能</h3>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#8bit16bit-タイマカウンタ\" id=\"user-content-8bit16bit-タイマカウンタ\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>8bit/16bit タイマ・カウンタ</h4>",
    "<p>ATmega328p には 8bit タイマ・カウンタが2つと 16git タイマ・カウンタが1つ搭載されています。",
    "それぞれが 4つの動作モードを持ち、また2つの 8bit タイマ・カウンタは機能はほぼ同じであるものの、",
    "セットできるプリスケールが異なるなどわずかに異なる仕様を持っていました。</p>",
    "<p>当初は予想できなかったのですが、このプロジェクトで最も苦戦したのがタイマ・カウンタの実装でした。",
    "1サイクルでもずれると、ズレは大きくなっていきレジスタの状態が合わせられなくなっていきますし、",
    "動作モードやプリスケールの切り替えでレジスタが書き変わるタイミングを厳密に把握する",
    "必要がありました。</p>",
    "<p>振り返ってみると、アプリケーションを書いていると普段は意識しない CPU のサイクルを",
    "感じられたという意味で良い経験になったと思います。</p>",
    "<h4><a aria-hidden=\"true\" class=\"anchor\" href=\"#io-ポート\" id=\"user-content-io-ポート\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>I/O ポート</h4>",
    "<p>AVR マイコンにはデジタル入出力を行うためのピンが多数用意されていて、それらが IO ポート",
    "に対応しています。</p>",
    "<ul>",
    "<li>DDRx レジスタを '0' にすると入力ポートに、'1' にすると出力ポートになる</li>",
    "<li>PORTx レジスタを '0' にすると出力ポートは'Low'に、'1' にすると出力ポートは'High'になる（入力ポートの場合は内部プルアップがアクティブになる）</li>",
    "<li>PINx レジスタを参照して入力の '0' / '1' を読み取る</li>",
    "</ul>",
    "<p>これもタイマ・カウンタと同様に、システム・クロックと各レジスタの動作のブロック図を見ながら",
    "仕様を把握する必要がありました。</p>",
    "<h3><a aria-hidden=\"true\" class=\"anchor\" href=\"#e-webassembly-対応\" id=\"user-content-e-webassembly-対応\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>E. WebAssembly 対応</h3>",
    "<p>今回作ったエミュレータはブラウザで動作させたかったので WebAssembly 対応をしました。",
    "AVRMCU トレイトで定義した振る舞いを wasm での IF としてそのまま残しています。</p>",
    "<div class=\"highlight highlight-source-rust\"><pre>#[wasm_bindgen]",
    "<span class=\"pl-k\">pub</span> <span class=\"pl-k\">struct</span> <span class=\"pl-en\">AvrMcu</span> {",
    "    avr: <span class=\"pl-k\">Box</span><span class=\"pl-k\">&lt;</span><span class=\"pl-k\">dyn</span> AVRMCU<span class=\"pl-k\">&gt;</span>",
    "}",
    "",
    "#[wasm_bindgen]",
    "<span class=\"pl-k\">impl</span> <span class=\"pl-en\">AvrMcu</span> {",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">new_atmega328p</span>() -&gt; AvrMcu {",
    "        <span class=\"pl-k\">let</span> avr <span class=\"pl-k\">=</span> atmega328p<span class=\"pl-k\">::</span>ATmega328P<span class=\"pl-k\">::</span><span class=\"pl-en\">new</span>(atmega328p<span class=\"pl-k\">::</span>Package<span class=\"pl-k\">::</span>PDIP28);",
    "        AvrMcu {",
    "            avr: <span class=\"pl-k\">Box</span><span class=\"pl-k\">::</span><span class=\"pl-en\">new</span>(avr),",
    "        }",
    "    }",
    "",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">program</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>, hex: <span class=\"pl-k\">String</span>) {",
    "        <span class=\"pl-c1\">self</span>.avr.<span class=\"pl-en\">program</span>(hex)",
    "    }",
    "",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">initialize</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-c1\">self</span>) {",
    "        <span class=\"pl-c1\">self</span>.avr.<span class=\"pl-en\">initialize</span>();",
    "    }",
    "",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">get_pins</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>) -&gt; <span class=\"pl-k\">String</span> {",
    "        <span class=\"pl-en\">from_vec_bool_to_string</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>.avr.<span class=\"pl-en\">get_pins</span>())",
    "    }",
    "",
    "    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">set_pins</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>, pins: <span class=\"pl-k\">String</span>) {",
    "        <span class=\"pl-c1\">self</span>.avr.<span class=\"pl-en\">set_pins</span>(<span class=\"pl-en\">from_string_to_vec_bool</span>(<span class=\"pl-k\">&amp;</span>pins));",
    "    }",
    "}</pre></div>",
    "<h2><a aria-hidden=\"true\" class=\"anchor\" href=\"#終わりに\" id=\"user-content-終わりに\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>終わりに</h2>",
    "<p>今回のプロジェクトは成功とは言えない終わり方になりましたが、知識面やメンタル面で良い経験になりました。",
    "プロジェクトを始めた時は CPU やマイコンの知識もなく、また Rust での開発も初めてだったのですが、",
    "文献を調べたり、他のエミュレータプロジェクトのソースコードを読むことでなんとか形にすることができました。",
    "また、1クロックレベルで挙動をデバッグし続けた時（仕様書にもないレジスタの挙動を管理する必要がありました）",
    "は何度ももうダメだと思いましたが、根気でやり続けるうちに解決できたのも印象に残っています。",
    "このプロジェクトから、勢いをつけて勉強すること、諦めず粘り強く打ち込むことの大切さが分かった気がしました。</p>",
    "<p>また、マイコンというアナログとデジタルの境界が今回のターゲットでしたが、計算機",
    "の得意・不得意をはっきり感じました。CPU の挙動は純粋な計算モデルとして綺麗にコード化",
    "のイメージがつきましたが、マイコンの周辺機能は物理の世界と密接に関わっていて、",
    "これを計算機で表現するとなると途端に難しくなるという印象を持ちました。",
    "当たり前ではありますが、連続的な物理量は離散的なプログラムで表現しづらく、",
    "このあたりの得意・不得意の線引きの感覚を持っておくべきだったと思います。</p>",
    "<p>プログラマとしては、最も低レイヤーの CPU の挙動の基礎が分かったので、",
    "次は OS や言語処理系といった階層について学んでいきます。</p>",
    "<h2><a aria-hidden=\"true\" class=\"anchor\" href=\"#参考文献\" id=\"user-content-参考文献\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" fill-rule=\"evenodd\"></path></svg></a>参考文献</h2>",
    "<ul>",
    "<li><a href=\"https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%81%AE%E6%A7%8B%E6%88%90%E3%81%A8%E8%A8%AD%E8%A8%88-%E7%AC%AC5%E7%89%88-%E4%B8%8A-%E3%82%B8%E3%83%A7%E3%83%B3%E3%83%BBL-%E3%83%98%E3%83%8D%E3%82%B7%E3%83%BC/dp/4822298426\" rel=\"nofollow\">パターソン&amp;ヘネシー コンピュータの構成と設計 上下</a></li>",
    "<li><a href=\"https://www.amazon.co.jp/CPU%E3%81%AE%E5%89%B5%E3%82%8A%E3%81%8B%E3%81%9F-%E6%B8%A1%E6%B3%A2-%E9%83%81/dp/4839909865/ref=pd_bxgy_img_3/357-8409700-7212621?_encoding=UTF8&amp;pd_rd_i=4839909865&amp;pd_rd_r=06c3877d-f9ff-469a-9556-d70c4a933d50&amp;pd_rd_w=UzV7H&amp;pd_rd_wg=mJ1hd&amp;pf_rd_p=e64b0a81-ca1b-4802-bd2c-a4b65bccc76e&amp;pf_rd_r=AF60XDDE01V17X6TQ6GM&amp;psc=1&amp;refRID=AF60XDDE01V17X6TQ6GM\" rel=\"nofollow\">CPUの創り方</a></li>",
    "<li><a href=\"https://www.amazon.co.jp/AVR%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3%E3%83%BB%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%83%BB%E3%83%96%E3%83%83%E3%82%AF%E2%80%95AVR%E3%81%AECPU%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%80%81%E8%B1%8A%E5%AF%8C%E3%81%AA%E5%86%85%E8%94%B5%E5%91%A8%E8%BE%BA%E6%A9%9F%E8%83%BD%E3%82%92%E8%A9%B3%E7%B4%B0%E8%A7%A3%E8%AA%AC-%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3%E6%B4%BB%E7%94%A8%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E5%B1%B1%E6%A0%B9-%E5%BD%B0/dp/4789837300\" rel=\"nofollow\">AVRマイコン リファレンス・ブック</a></li>",
    "<li><a href=\"https://www.amazon.co.jp/%E8%A9%A6%E3%81%97%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6AVR%E5%85%A5%E9%96%80%E2%80%95%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3%E3%81%AE%E5%9F%BA%E7%A4%8E%E3%81%A8%E9%9B%BB%E5%AD%90%E5%B7%A5%E4%BD%9C%E3%81%A8Windows%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9-SkiLL-up-mycomputer%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E5%9C%9F%E4%BA%95/dp/4789846040/ref=pd_sbs_1?pd_rd_w=1U3Mz&amp;pf_rd_p=1821eedd-9050-44ff-9f94-4ca9c8c19ec5&amp;pf_rd_r=P0DWRSE15P04WMXTEYV4&amp;pd_rd_r=b160992d-ff50-493a-98d4-dd45c239ac77&amp;pd_rd_wg=4YHU3&amp;pd_rd_i=4789846040&amp;psc=1\" rel=\"nofollow\">試しながら学ぶ AVR 入門</a></li>",
    "<li><a href=\"https://github.com/kamiyaowl/rust-nes-emulator\">kamiyaowl/rust-nes-emulator</a></li>",
    "</ul>",
    "</article>",
    "</div>"
  ],
  "dir": "src/articles",
  "base": "2021-01-18.json",
  "ext": ".json",
  "sourceBase": "2021-01-18.md",
  "sourceExt": ".md"
}