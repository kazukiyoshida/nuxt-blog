# Rust が何故好きなのか

いろいろな言語を触ってきましたが、Rust が格別に好きなのでその良さを話したいと思います。

筆者は Rust 歴2年弱程度で、まだまだ勉強中です。  
もし間違っていることを書いていたらご指摘ください。  

## なぜ Rust が好きなのか？

要約すると、Rust が好きな理由は  

**① 関数型のエッセンスを持ったモダンな言語仕様** を持ち、  
**② C言語に匹敵する実行速度** が出せて  
**③ メモリ安全性・データ競合安全性まで担保** してくれて、  
**④ 周辺ツールが整っている**  

という 4 点にあります。

それぞれの点について、自分が気に入っている点をみていきます。


## ①  関数型のエッセンスを持ったモダンな言語仕様

### Hindley Milner 型推論

Rust は静的型付け言語であり、型推論をサポートしています。  
型推論もいろいろな形式がありますが、Haskell や OCaml など関数型言語で取り入れられて
いる Hindley Milner 型推論をベースにしているのが特徴です。

Hindley Milner 型推論は非常に強力で、式の前後関係から型を一意に決定しようとします。

```rust
// Rust
if "true".parse().unwrap() {
// ~~~~~~~~~~~~~~~~~~~~~~~ if の評価式に当たるため、bool 型にパースします.
    println!("ok");
}
```

Go, Kotlin, TypeScript など、現代的な言語の多くに型推論はサポートされていますが HM 型推論とは異なります。  
例えば Go で同様のコードを書くなら、明示的に型を記述する必要があります.

```go
// Go
var toBool bool
toBool, _ = strconv.ParseBool("true")

if toBool {
	fmt.Printf("ok")
}
```

スニペットだと伝わりづらいですが、コンパイラに人工知能でも入ってるのかな？笑 というくらい賢いです.
一度ビルドが通ればまず間違いなく動作します。


### 代数的データ型

関数型言語で広くサポートされている代数的データ型を、Rust は「値を持つ列挙型」として取り入れています。  
代数的データ型は考えているデータ空間をそのまま表現できるので、個人的に非常に好きな機能です。  

例えば Bitcoin のアセットクラスとして現物、無期限スワップ、1週間先物、があったとします。  
1週間先物は満期日によって異なるので 10JUL2020, 17JUL2020, .. と続いていきますが、Rust ではこれをそのまま型として表現できます。  

```rust
enum Asset {
    BTCJPYspot,             // 現物
    BTCJPYperp,             // 無期限スワップ
    BTCJPY1week(Date<Utc>), // 1週間先物（10JUL2020, 17JUL2020, ..）
}
```

### パターンマッチ

初めての方には when構文、 switch構文（どちらも本質的には if 分岐）と match式（パターンマッチ）の違いが分かりづらいですが、両者は全く異なります。  
パターンマッチは if 分岐よりも強力です。

パターンマッチは代数的データ型と非常に相性が良いです. また、全ての分岐を網羅しているかコンパイラがチェックします.  

```rust
match asset {
    Asset::BTCJPYspot | Asset::BTCJPYperp           => println!("現物 or 無期限スワップ"),
    Asset::BTCJPY1week(date) if date < Utc::today() => println!("満期日が過去の1週間先物 満期日: {:?}", date), // 条件付きパターン（ガード節）
    Asset::BTCJPY1week(date)                        => println!("1週間先物 満期日: {:?}", date), // この行がないとエラー
}
```

if 文は値によって分岐しますが、パターンマッチはデータ構造に応じて分岐します.

```rust
fn greet(people: &[&str]) {
    match people {
        []                => println!("0人.."),
        [one]             => println!("1人 {}", one),
        [one, two]        => println!("2人 {}, {}", one, two),
        [first, .., last] => println!("たくさん {}, {}", first, last),
    }
}

fn main() {
    greet(&["John", "Peter", "Stewart"]); // -> たくさん "John", "Stewart"
}
```

### エラー処理

Rust は代数的データ型とパターンマッチを言語の基礎に据えており、エラーハンドリングもこれを活用します.  
Rust には伝統的なオブジェクト指向言語で採用されている例外や try-catch 構文が存在しません.  
失敗する可能性のある処理の結果は Option 型、Result 型 を用いて厳密に管理します.

```rust
fn create_file_buffer(path: &str) -> Result<BufWriter<fs::File>, std::io::Error> {
    match fs::File::create(path) {
        Ok(file) => Ok(BufWriter::new(file)),
        Err(e) => Err(e),
    }
}
```

Rust は Haskell のようにモナドをサポートしている訳ではありませんが、
明らかにそれを意識したメソッドが Option, Result 型には多数用意されています.

```rust
fn create_file_buffer2(path: &str) -> Result<BufWriter<fs::File>, std::io::Error> {
    fs::File::create(path)
        .map(|file| BufWriter::new(file))
}
```



### トレイト

TODO



## ②  C言語に匹敵する実行速度

### ゼロオーバーヘッドの原則

Rust は Bjarne Stroustrup が C++ について
「[Abstraction and the C++ Machine Model](https://www.stroustrup.com/abstraction-and-machine.pdf)」
という論文で明言したものを目標としています.

> In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.

正確にこれを表現することは難しいですが、Rust の実装は  
　　**使わない機能によってメモリやCPUのコストが発生することはなく、  
　　使った機能によるコストはアセンブラのレベルで必要最小限とならねばならない**  
という原則に基づいていると解釈しています.

この原則に基づいているために、Rust は GC によるメモリ管理のオーバーヘッドを排除することを選択し、
言語のプリミティブな操作は計算機の挙動と密接に対応するようになっています.
このため、開発者は Rust の高度な抽象化の仕組みを使いながらもメモリの使い方を細かく制御することができ、
実行されるコードのコストを見積もることができます.

Rust の実行速度が十分に速く、組み込みや OS といったシビアな要件に堪えるのは、このゼロオーバーヘッドの原則に
従うという設計方針に由来しています.

※ ちなみに「ゼロコスト抽象化」という言葉は
「Rust がサポートする高度な抽象化の仕組みもゼロオーバーヘッドの原則に従う」という意味で用いられていると思われます.

### ランタイムのないネイティブコードを生成する

rustc コンパイラはネイティブコードを生成します.
バックエンドは LLVM でありマルチプラットフォームに対応しています.

Rust で API サーバーを書くなら Docker コンテナとしてデプロイすることになると思いますが、
標準Cライブラリ musl に静的リンクさせたシングルバイナリを作成できるので、ベースイメージは alpine である
必要もありません. Linux カーネルだけ存在すれば良いので、scratch で十分です.

```dockerfile
# Dockerfile
FROM ekidd/rust-musl-builder:latest AS builder              # multi stage build させます. rustl-musl-builder は musl-libc や openssl など外部ライブラリを用意したイメージ.
..                                                          # なんやかんやの処理は省略します
RUN cargo build --release --bin data_collection_server      # 最適化オプションや strip の実行は省略

FROM scratch                                                # scratch イメージの上にバイナリファイルを持ってきます
COPY --from=builder \
  /home/rust/src/target/x86_64-unknown-linux-musl/release/data_collection_server /
..
```

Rust はメモリ管理の仕組みとしてスマートポインタを採用しており、上述の通り GC がありません.  
[典型的な意味でのランタイムを持たず](https://prev.rust-lang.org/ja-JP/faq.html#does-rust-have-a-runtime)、リソース管理のオーバーヘッドが発生しません.

ランタイムがないことにより、実行ファイルや WebAssembly ファイルのサイズが、Go などと比べると小さくなります
（補足しておくと、C, C++ よりは大くなるようです）  

標準でランタイムがないことのトレードオフも、ここでは補足しておきます.  
2019年末の Rust 1.39 にめでたく async-await 構文が stable でサポートされました.
しかし非同期ランタイムは標準にないため外部クレートに依存する必要があります.  

```
# Cargo.toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

```rust
#[tokio::main]
async fn main() {
    async {
        println!("hello, async block");
    }.await;
}
```

またランタイムがないため Go の goroutine のような軽量スレッド（グリーンスレッド）も標準ではサポートされていません.  
このあたりは言語設計のトレードオフとして把握しておくべきかもしれません.  

### 多相性とゼロコスト抽象化

Rust は多相性（polymorphism）をジェネリクスとトレイトという 2 つの方式でサポートしています.
どちらも高度な抽象化の仕組みですが、それでも開発者はメモリの使い方を完全にコントロールできます.

ジェネリクスで書かれたコードはコンパイル時に最適化され、実行時は静的にディスパッチされます（当然ですが、その分バイナリサイズは肥大化します）.
逆にトレイトで書かれたコードは動的ディスパッチによって実行されます.

```rust
// 「甘いもの」という振る舞いを定義
trait Sweet {}

// ドーナツ
struct Donut;
impl Sweet for Donut {}

// ケーキ
struct Cake;
impl Sweet for Cake {}

// デザートセットのメニューを定義したい..
struct DessertSetA<T: Sweet> { // ジェネリクスを使っているので静的ディスパッチ
    menu: Vec<T>,              // ちなみに、1種類の「甘いもの」しか選択できない（ドーナツだけ、とか）
}

// デザートセットのメニューを定義したい..
struct DessertSetB {       // とレイトオブジェクトを参照しているので動的ディスパッチ
    menu: Vec<Box<Sweet>>, // 複数の「甘いもの」を含められる（ドーナツ・ケーキ.. など）
}
```

### 関数とゼロコスト抽象化

Rust では通常の関数とクロージャを使うことができます.
どちらも静的にディスパッチされ、インライン化・最適化が行われます.

```rust
fn add(x: i32) -> i32 { x + 1 }

let add_function: fn(x: i32) -> i32 = add;            // 関数ポインタ
let add_closure                     = |x: i32| x + 1; // クロージャ（型はコンパイル時にアドホックに決定）

println!("{}", add_function(1)); // インライン展開され、println!(2) と同等になる（はず）
println!("{}", add_closure(1));  // インライン展開され、println!(2) と同等になる（はず）
```

## ③  メモリ安全性・データ競合安全性まで担保

### メモリ安全性

Rust ではデータの所有権とライフタイムをコンパイラが精査してくれます.
[重大度の高いセキュリティバグの約70%がメモリ安全性に起因している](https://www.chromium.org/Home/chromium-security/memory-safety)
という報告もありますが、Rust はこれをコンパイル時に検出してくれます.

Rust の変数には生存期間があります.
```rust
{                          // --  カッコ {  } でスコープが区切られる
    let a = vec![1, 2, 3]; //   |
}                          // --  変数 a 生存期間はここまで
                           //     （ヒープに確保されたベクタ[1,2,3] もこの時点で解放される）

// println!("{:?}", a);    // a の生存期間が過ぎているためコンパイルエラー
```

また、変数が参照しているデータが解放されるタイミングも検査しているため、
Rust ではダングリングポインタが作れません.
```rust
let a;
{                       // --
    a = &vec![1,2,3];   //   | ヒープにベクタ[1,2,3] を確保する. a は値の所有権は持たず参照を持つ
}                       // --  ベクタ[1,2,3] はこの時点で解放される

// println!("{:?}", a); // 変数 a は生きているが、ベクタデータは解放されてるので、
                        // a がダングリングポインタとなり、コンパイラがこれを検知してエラー.
```

変数同士の参照は所有権の移動となります.
JavaScript や Python のように、うっかり値が書き換えられてしまうことがありません.
```rust
let a = vec![1, 2, 3];
let b = a;              // ベクタデータの所有権を変数 a から変数 b に移動（move）.
                        // 変数 a は未初期化状態になる.

// println!("{:?}", a); // 変数 a は未初期化状態なのでコンパイルエラー.
```

### データ競合安全性

並行処理プログラミングも、他の言語と比べると非常に安全に行えるようになっています.
Rust ではデータの所有権が明確になっているため、スレッドを跨いだデータの共有が行われないことが検査されます.
また、Thread 間で可変なオブジェクトを共有する際は、Mutex を用いて排他制御を行います.

Rust でデータ競合安全性を担保しているのは Send、Sync という2つのトレイトです.
- Send : 所有権をスレッド間で受け渡しても安全であることを保証する
- Sync : 複数のスレッドから参照されても安全であることを保証する  
これらをコンパイラがチェックしているために、データ競合などの未定義動作が発生することはありません.

例えば参照カウンタ型 Rc は、共有参照カウントを複数のスレッドで同時にインクリメントすることになりかねないので、
Send, Sync どちらも実装されていません.

```rust
let rc = Rc::new(0);
spawn(move || {      // コンパイルエラー. Rc<T> は Send を実装していない.
    rc;
});
```

## ④  周辺ツールが整っている

### cargo, rustup が good

cargo は TOML で設定を記述できるのでスッキリしています.
また Rust のモジュールシステムはビルドターゲットがライブラリとバイナリで明確に分かれているので、
1つのプロジェクトで複数の実行バイナリを用意できるのが個人的に非常に気に入っています.

Rust のツールは公式プロジェクトに含まれる rustup で管理できるのも環境構築がスムーズで良いです.


### エラーメッセージが丁寧

rustc のエラーメッセージは丁寧で視覚的にも分かりやすいです（実際はカラフルに出力されます）.

```
error[E0308]: mismatched types
 --> src/main.rs:3:22
  |
3 |         let x: f64 = i;
  |                ---   ^ expected `f64`, found integer
  |                |
  |                expected due to this
```

### WebAssembly に対応

Rust のコードがあればそれを WebAssembly にコンパイルすることができます.  
前述の通りランタイムがないので非常に小さいサイズになります.

Rust ではアトリビュートでコードを装飾することができるので、慣れれば非常に読みやすいコードになります.


## 個人的に思う Rust の弱点

### 高い学習コスト、エンジニア確保の難しさ

Rust に慣れない頃はコンパイルを通すのもやっとという感じで難しかったです.
チームで Web 開発をするなら、自分なら Go を選ぶかもしれません.

### 標準ライブラリが薄い

HTTP クライアントや非同期ランタイムなど、重要なものも外部クレートに依存する必要があります.
今後 npm のようににならないか少々心配.

### コンパイルに時間がかかる

本番向けの Docker イメージ作成でフルビルドさせると、自分の環境では 15分くらいかかったりします.

これは Docker ビルドでのテクニックですが、[依存ライブラリをキャッシュさせるために
ダミーの main 関数を仕込む](https://stackoverflow.com/questions/58473606/cache-rust-dependencies-with-docker-build)
など、対応が必要です.

### 循環参照のあるデータ構造が少々作りづらい

グラフなど、循環参照のあるデータ構造を作る場合は Rc, RefCell で内部可変性のパターンを用いる必要があります.  
例えば連結リストを実装するとこんな感じになります.

```rust
struct Node {
    value: String,
    next: SingleLink,
}

type SingleLink = Option<Rc<RefCell<Node>>>;

struct LinkedList {
    head: SingleLink,
    tail: SingleLink,
    pub length: u64,
}
```

### 浮動小数点数の丸めモードを制御できない

LLVM が対応していないことが原因ですが、浮動小数点数の丸めモードを制御できないようです.  
自分は使ったことがないですが、用途によってはクリティカルになり、C++ を使う必要があるとのこと.

### GCP と相性悪い？

