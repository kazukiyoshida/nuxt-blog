
「どうやら Rust は良いらしい」  

というぼんやりとした動機で勉強を始め、
趣味のプロジェクトで使っていくうちに気づけば Rust の魅力にすっかりはまってしまいました。
今回はこれから Rust を勉強する方、興味はあるけどきっかけがないという方に向けて、
私の考える Rust の魅力（のごく一部）をまとめてみたいと思います。
言語機能の細かい解説には触れませんが、Rust の哲学やその先進的な機能のいくつかを
ご紹介することで、興味を持っていただければ幸いです。

今回の記事で紹介するコードは Rust 1.49.0 stable で動作確認済です。

## なぜ Rust が好きなのか？

早速ですが、私が Rust を好きな理由を要約すると

**① 関数型のエッセンスを持ったモダンな言語仕様** である  
**② C言語と同等の実行速度** がだせる  
**③ メモリ安全性・データ競合安全性まで担保** してくれる  
**④ 周辺ツールが整っている**   

という4つにまとめられます。

Rust は Haskell などの静的型付け関数型言語で導入されている型推論や型クラス、
エラー処理などをサポートしていて、言語体系として整っている印象があります。

Rust がサポートしている型推論や型クラス、例外を用いないエラー処理といった機能は、
Haskell に代表される関数型言語で導入され有用性が証明されたものです。
実際に私が Haskell を書いていた時は、そういった言語機能のおかげで綺麗にコードが
書けて楽しかったのですが、その一方でライブラリが揃わないとか、気を抜くとメモリを使い過ぎる
という点で、Web システムを書くのは難しいと感じていました。
Rust は関数型言語の先進的な機能を取り入れながら、C 言語と同等に速いソフトウェアを書くことができ、
Web 開発にも堪えるというまさに理想的な言語でした。

さらに、実行速度と関数型の機能に加えて、Rust はメモリ安全性・データ競合安全性も担保します。
この機能によって Rust で書かれたコードはコンパイル時に安全性を検査されるため、
オブジェクト指向言語で発生する NullPointerException や、システムの脆弱性につながる
Dangling Pointer といった問題を未然に防ぎます。さらに、比較的新しい言語ということもあり、
パッケージマネージャ、テスト、ドキュメンテーションといった開発に必須のツールが
公式に整備されていて、コーディングを快適に進めることができます。


## ①  関数型のエッセンスを持ったモダンな言語仕様

### Hindley Milner 型推論

まず紹介したいのが、Rust の持つ強力な型推論の機能です。
Rust は静的型付け言語であり型推論をサポートしているのですが、そのベースとして
Haskell や OCaml など関数型言語で多く取り入れられている Hindley Milner 型推論を採用しています。

Go、Kotlin、TypeScript など現代的な言語の多くが型推論をサポートしていますが、
その多くは変数への代入や関数の引数、戻り値といったシンプルなケースで型を推論するにとどまります。

具体的な例として、Go で文字列をパースするコードを書く場合、明示的に型を指定する必要があります。

```go
// Go
var toBool bool
toBool, _ = strconv.ParseBool("true")

if toBool {
	fmt.Printf("ok")
}
```

Rust が採用している Hindley Milner 型推論は非常に強力で、式の前後関係から型を一意に決定しようとします。
例えば String型の関数 `parse<F>` はジェネリックな関数となっていて、コンパイラが 型 `F` を推論してくれます。

```rust
// Rust
if "true".parse().unwrap() {
// ~~~~~~~~~~~~~~~~~~~~~~~ if の評価式に当たるため、bool 型にパースする.
    println!("ok");
}
```

実際にコードを書いてみると、驚くほどコンパイラが賢く、どんなに複雑なコードでも厳密に型をチェックしてくれます。
私の体感では、一度ビルドが通ればアプリケーションはまず動作します。


### 代数的データ型

関数型言語で広くサポートされている代数的データ型も私の好きな機能の一つです。
代数的データ型を用いると、考えているデータ空間をそのまま型として表現でき、型推論や後述する
パターンマッチと組み合わせて堅牢なアプリケーションを記述できます。

Rust はこの代数的データ型を値付き列挙型(Enum) としてサポートしています。

具体的な例として Bitcoin のアセットクラスを型として表現してみましょう。
ある取引所にはアセットクラスとして現物、無期限スワップ、1週間先物があったとします。
1週間先物は満期日によって異なるので 10JUL2020, 17JUL2020,.. と続いていきますが、
Rust はこれをそのまま型に落とし込むことができます。

```rust
enum Asset {
    BTCJPYspot,             // 現物
    BTCJPYperp,             // 無期限スワップ
    BTCJPY1week(Date<Utc>), // 1週間先物（10JUL2020, 17JUL2020, ..）
}
```

イメージとしては、Enum が 1次元の有界な離散空間しか表現できなかったものが、
代数的データ型によって任意の次元・構造の空間を表現できるようになった、という感覚です。

### パターンマッチ

代数的データ型の威力を引き出すのがパターンマッチです。
私自身、初めて勉強した時はオーソドックスな if構文、switch 構文との違いが分からなかったのですが、
よく見てみるとパターンマッチはそれらよりも表現力がはるかに強化されています。

パターンマッチは値による場合分けをしつつ、全てのパターンが網羅されているかをコンパイラがチェックします。

```rust
match asset {
    Asset::BTCJPYspot | Asset::BTCJPYperp           => println!("現物 or 無期限スワップ"),
    Asset::BTCJPY1week(date) if date < Utc::today() => println!("満期日が過去の1週間先物 満期日: {:?}", date), // 条件付きパターン（ガード節）
    Asset::BTCJPY1week(date)                        => println!("1週間先物 満期日: {:?}", date), // この行がないとエラー！
}
```

if構文は値によって分岐するが、パターンマッチはデータ構造に応じて分岐する、とも考えられます。

```rust
fn greet(people: &[&str]) {
    match people {
        []                => println!("0人.."),
        [one]             => println!("1人 {}", one),
        [one, two]        => println!("2人 {}, {}", one, two),
        [first, .., last] => println!("たくさん {}, {}", first, last),
    }
}
```

### エラー処理

これまで見たように、Rust は強力な型推論や代数的データ型、パターンマッチを備えていて、
アプリケーション全体をきっちりと型で固める言語です。そんな Rust はエラー処理も同様の流儀で
厳格に扱います。

多くのオブジェクト指向言語はエラー処理を例外（Exception）と try-catch 構文によって実装します。
この方法は分かりやすく素早くコードを書けるというメリットがあるものの、次のような側面もあります。

- 関数内部でエラーが発生するのかどうかを型から判断できない
- エラー処理を用意するかどうかは開発者の丁寧さに委ねられている

また、Go のように戻り値に処理の結果を添えるというエラー処理方式もありますが、
これもエラーチェック漏れを検知することができません。

Rust のエラー処理はこれらと全く異なっていて、Option型・Result型 を用いて処理の結果を厳密に管理します。
処理が失敗するかどうかは型を読むことで一眼で分かりますし、処理の成功時・失敗時の両方の
ケースを実装しないとコンパイルが通らないようになっています.

```rust
//
// 整数 x, y に対して x/y を計算する
// y が 0 の場合は計算できないため失敗 None を返し、それ以外は成功 Some(x/y) を返す
//
fn divide(x: i32, y: i32) -> Option<i32> {
    if y == 0 { None } else { Some(x / y) }
}
```

### トレイト

Rust にはクラスや継承といった機能がなく、代わりにトレイトという、関数型言語でサポートされている
機能を採用しています。トレイトは「型の振る舞い・性質」を定義したものです。

例えば「一致の検証ができる」という性質は Eq トレイトで定義され、
「順序付けができる」という性質は Ord トレイトで定義されます。
整数型 u8 は一致の検証も順序付けもできるので Eq、Ord トレイトの両方を実装されていますが、
文字列型 String は一致の検証はできるものの、順序付けは普通はできないので Eq トレイトのみ実装されています。

<img src="https://github.com/kazukiyoshida/nuxt-blog/blob/master/src/assets/images/20210108/trait1.png" alt="trait1" width="700">

オブジェクト指向言語では継承によって型の階層構造を作りますが、
Rust では型の振る舞いを列挙していくので、イメージとしては水平方向の広がりになっています。
ちなみにトレイトはトレイトに依存できるため、トレイトの関係性によって縦方向の広がりも存在しています。

<img src="https://github.com/kazukiyoshida/nuxt-blog/blob/master/src/assets/images/20210108/trait2.png" alt="trait2" width="400">

トレイトは**それが何であるか**を定義するという意味で宣言的な機能だと言えます。
継承よりもトレイトの方が型の振る舞いをイメージしやすいので個人的に非常に気に入っています。


## ②  C言語に匹敵する実行速度

Rust は C言語に匹敵する実行速度が出せる
（[あるいは C よりも速い](https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html)）
、数少ない言語の一つです。その背景には、ゼロオーバーヘッドの原則に従うという徹底した姿勢があります。

### ゼロオーバーヘッドの原則

ゼロオーバーヘッドの原則とは、 2005年に Bjarne Stroustrup が
「[Abstraction and the C++ Machine Model](https://www.stroustrup.com/abstraction-and-machine.pdf)」
という論文で明言したものです。

> In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.

**使わない機能によってメモリやCPUのコストが発生することはなく、  
使った機能によるコストはアセンブラのレベルで必要最小限とならねばならない** （筆者訳）  

C++ と同様に Rust もこのゼロオーバーヘッドの原則に従っていて、いろいろな機能で
ゼロコスト性が意識されています。無駄な処理が実行されないようになっているので、
開発者はコードを読むことで実行コストを見積もることができ、そのためリアルタイムOS や
金融商品の高頻度取引システムなど、要件が厳しいプロジェクトでも Rust を採用することができます。


### ランタイムのないネイティブコードを生成する

Rust は GC を持たずスマートポインタでメモリを管理します。 また、Go の goroutine のような
グリーンスレッドを管理するランタイムも持たないため、リソース管理のオーバーヘッドが発生しません。

開発者はランタイムを導入することも選択できます！2019年末の Rust 1.39 で async-await 構文が安定化されたので、
今や非同期処理はわずか数行で導入することができます。さらに、後述するように Rust の Future はゼロコスト性も備えています。

```
# Cargo.toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

```rust
#[tokio::main]
async fn main() {
    async {
        println!("hello, async block");
    }.await;
}
```

また、標準 C ライブラリ musl に静的リンクしたバイナリを簡単に作れるので、
scratch な Docker イメージ上でこれを実行できる点も非常に気に入っています。

```dockerfile
# Dockerfile
FROM ekidd/rust-musl-builder:latest AS builder              # multi stage build させます. rustl-musl-builder は musl-libc や openssl など外部ライブラリを用意したイメージです.
..
RUN cargo build --release --bin data_collection_server      # 最適化オプションや strip の実行は省略

FROM scratch                                                # scratch イメージ！alpine よりも小さい、最小のイメージです.
COPY --from=builder \
  /home/rust/src/target/x86_64-unknown-linux-musl/release/data_collection_server /
..
```

### 多相性とゼロコスト抽象化

Rust は多相性（polymorphism）をジェネリクスとトレイトオブジェクトという 2 つの機能でサポートしています。
どちらも高度な抽象化の仕組みですが、それでも開発者はメモリの使い方を完全にコントロールできます。

- ジェネリクス：コンパイル時にインライン化・最適化され、実行時は静的にディスパッチされる
- トレイトオブジェクト：動的ディスパッチによって実行される

具体例として、スイーツセットを実装してみましょう。ジェネリックに定義したスイーツセットは
静的に型が決定するため 1種類のスイーツしか選択できず、その代わりコードは最適化されます。
一方で、トレイトオブジェクトによって定義されたスイーツセットにはいろいろなスイーツを詰め合わせることができます。

```rust
// 「甘いもの」という振る舞いを定義
trait Sweet {}

// ドーナツ
struct Donut;
impl Sweet for Donut {}

// ケーキ
struct Cake;
impl Sweet for Cake {}

// デザートセットのメニューを定義したい..
struct DessertSetA<T: Sweet> {     // ジェネリクスを使っているので静的ディスパッチ
    menu: Vec<T>,                  // 1種類の「甘いもの」しか選択できない（ドーナツだけ、とか）
}

// デザートセットのメニューを定義したい..
struct DessertSetB {               // トレイトオブジェクトを参照しているので動的ディスパッチ
    menu: Vec<Box<Sweet>>,         // 複数の「甘いもの」を含められる（ドーナツ・ケーキ.. など）
}
```

### 関数とゼロコスト抽象化

Rust では通常の関数だけでなくクロージャも使えます。
どちらも静的にディスパッチされ、インライン化・最適化が行われます。

```rust
fn add(x: i32) -> i32 { x + 1 }

let add_function: fn(x: i32) -> i32 = add;            // 関数ポインタ
let add_closure                     = |x: i32| x + 1; // クロージャ（型はコンパイル時にアドホックに決定）

println!("{}", add_function(1)); // インライン展開され、println!(2) と同等になる（はず）
println!("{}", add_closure(1));  // インライン展開され、println!(2) と同等になる（はず）
```

### ゼロコスト Future

Rust 1.36 で安定化された Future ですが、 JavaScript などのそれと違い[ゼロコストになるよう設計](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html#zero-cost-futures)
されています。JavaScript の Future は作成されたら直ちにスケジューリングされるようになっていて、
そのため future が作成される度にオーバーヘッドが発生します。一方で Rust の Future は
await されるまで作成すらしないようになっています。


## ③  メモリ安全性・データ競合安全性まで担保

### メモリ安全性

Rust ではデータの所有権とライフタイムをコンパイラが精査してくれます。
[重大度の高いセキュリティバグの約70%がメモリ安全性に起因している](https://www.chromium.org/Home/chromium-security/memory-safety)
という報告もありますが、Rust はこのような問題をコンパイル時に検出してくれます。

1. Rust の変数には生存期間があります。
2. Rust の変数はデータの所有権を持ちます。
```rust
{                          // --  カッコ {  } でスコープが区切られる
    let a = vec![1, 2, 3]; //   | 変数 a がベクタの所有権を持つ.
}                          // --  変数 a 生存期間はここまで.
                           //     （所有権を持つ変数が死んだため、ヒープに確保されたベクタ[1,2,3] もこの時点で解放される）

// println!("{:?}", a);    // a が死んでいるためコンパイルエラー
```

3. Rust はデータを *参照* することができます。

1 ~ 3 の機能によって Rust はダングリングポインタを防ぎます。

```rust
let a;
{                       // --
    a = &vec![1,2,3];   //   | 一時的にヒープにベクタ[1,2,3] を確保する. 
                        //   | 変数 a はベクタの参照を持つ（所有権は持たない）
}                       // --  ベクタ[1,2,3] はこの時点で解放される

// println!("{:?}", a); // 変数 a は生きているが、ベクタデータは解放されてるので、
                        // a がダングリングポインタとなり、コンパイラがこれを検知してエラー.
```

上記は機能のごく一部ですが、Rust には所有権、参照、可変参照、
移動、生存期間など特有の機能があり、これらがメモリ安全性を担保してくれています。


### データ競合安全性

並行処理プログラミングも、他の言語と比べると非常に安全に行えるようになっています。
Rust ではデータの所有権が明確になっているため、スレッドを跨いだデータの共有が行われないことが検査されます。
また、スレッド間で可変なオブジェクトを共有する際は、Mutex を用いて排他制御を行います。

Rust でデータ競合安全性を担保しているのは Send、Sync という2つのトレイトです。

- Send : 所有権をスレッド間で受け渡しても安全であることを保証する
- Sync : 複数のスレッドから参照されても安全であることを保証する  

例えば参照カウンタ型 Rc は、共有参照カウントを複数のスレッドで同時にインクリメントすることになりかねないので、
Send, Sync どちらも実装されていません。

```rust
let rc = Rc::new(0);
thread::spawn(move || { rc; }); // コンパイルエラー. Rc<T> は Send を実装していない.
```

基本的な型は Rust のコアチームによってスレッド安全かどうか確認されており、
コンパイラはそれを Send, Sync としてチェックしています。
このため Rust ではデータ競合が発生しないようになっています。


## ④  周辺ツールが整っている

### cargo, rustup が良い

Rust のビルドシステム & パッケージマネージャ である cargo は、依存関係のあるライブラリ
の管理、ユニットテストの実行、ドキュメントの生成、などの機能を揃えています。

また Rust のツールは公式プロジェクトに含まれる rustup で管理できるので、
環境構築がスムーズなのも嬉しいです。

### モジュールシステムが良い

Rust のモジュールシステムはビルドターゲットがライブラリ部分とアプリケーション本体で明確に分かれています。
そのため 1つのプロジェクトのなかでライブラリを開発し、それを組み合わせたアプリケーションを
いくつも開発することができます。

### WebAssembly に対応

Rust のコードがあればそれを WebAssembly にコンパイルすることができます。
ツールが整っていて、attribute をいくつかコードに追記するだけで wasm ビルドできるので快適です。
また、ランタイムがないので実行ファイルが小さいサイズになります。

## 個人的に思う Rust の弱点

ここまで書いたように Rust は素晴らしい言語ですが、当然いくつかのトレードオフも存在します。
仕事で使う場合やプロジェクトの特性に応じて気を付けるべきと思う点を挙げてみます。

### 高い学習コスト、エンジニア確保の難しさ

日本語の書籍もあり、勉強しやすくなっているとは思いますが、初学者には難しく感じると思います。
チームで Web 開発をするなら、Go など生産性にフォーカスした言語を選ぶのも一択だと思います。

### 標準ライブラリが薄い

HTTP クライアントや非同期ランタイムなど、重要なものもサードパーティ製クレートに依存する必要があります。

### コンパイルに時間がかかる

本番向けのフルビルドを実行するとかなり時間がかかる印象があります。

これは Docker ビルドでのテクニックですが、[依存ライブラリをキャッシュさせるために
ダミーの main 関数を仕込む](https://stackoverflow.com/questions/58473606/cache-rust-dependencies-with-docker-build)
など、対応が必要だったりします。

### （良くも悪くも）循環参照のあるデータ構造が少々作りづらい

グラフなど、循環参照のあるデータ構造を作る場合は内部可変性と呼ばれる特有のパターンを用いる必要があります。
例えば連結リストを実装するとこんな感じになります。

```rust
type SingleLink = Option<Rc<RefCell<Node>>>;

struct Node {
    value: String,
    next: SingleLink,
}

struct LinkedList {
    head: SingleLink,
    tail: SingleLink,
    pub length: u64,
}
```

一方で、これはメリットとも考えられます。  
**Rust は所有権や生存期間の制約から、データ構造が一方向に流れるような設計を好みます。  
このため、書いていくうちにアプリケーション全体が自然と綺麗な構造に落ちていく印象があります。**

### 浮動小数点数の丸めモードを制御できない

LLVM が対応していないことが原因ですが、浮動小数点数の丸めモードを制御できないようです。
プロジェクトによってはクリティカルであるため、C++ を使う必要があります。

### もしかしたら GCP と相性悪いかも..？

GCP の公式 SDK は Rust をサポートしていないため、Rust 製アプリケーションで GCP
のマネージドサービスを操作する場合、Google APIs を利用することになります。
API を叩けば問題なく使えるのですが、認証などの点で少し手間がかかります。
有志のクレートも開発されていますが、本番環境に採用できるかはプロジェクト次第です。

一方で AWS は公式 SDK として [Rusoto](https://github.com/rusoto/rusoto) を提供しています。
AWS は自社サービスに Rust を積極的に活用しているという情報もあるので、相性の良さで言えば AWS に軍配が上がりそうです。


## おわりに

Rust は楽しく書きながら高速で安全なソフトウェアを書ける素敵な言語です。
また、一度 Rust を学ぶと安全なデータ操作や例外処理について意識するようになり、
他の言語を書く時でもその経験が活かされます。この記事で Rust に興味を持っていただけたら嬉しく思います。

最後に、個人的にオススメの参考書を紹介します。少しバージョンが古いですが Rust の
基本機能について計算機との関わり方を丁寧に図解しながら解説しているので、本腰を入れて
勉強する場合は参考になると思います。
- [プログラミングRust](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0Rust-Jim-Blandy/dp/4873118557)
