電子工作を気軽に楽しめる [Arduino](https://www.arduino.cc/) というマイコンボードをご存知でしょうか。
ボードとパーツを用意して Arduino 言語でプログラミングをすることで、
初心者でも簡単にセンサーの制御やモーターの駆動などを楽しめるようにした人気のプラットフォームです。

今回はその Arduino のマイコンとして採用されている Atmel AVR マイクロコントローラの
エミュレータを Rust で実装した話を書いてみます。

AVR マイコンは非常に多機能で、最終的には**マイコンのエミュレータ**を完全な形で実装することは
難しいと気付いたのですが、その過程の中で最低限動作するエミュレータができました。
Rust で実装する CPU エミュレータに興味がある方、Arduino の CPU の詳細に興味がある方
の参考になれば幸いです。

ソースコードは[こちら](https://github.com/kazukiyoshida/avr-emulator)に公開しています。  
言語は Rust 1.46、動作環境は macOS Catalina 10.15.7 です。

## AVR マイコンとは

AVR はアトメル社が開発した RISC ベース 8bit マイクロコントローラです。CPU、メモリ、
IOポート、クロック発振回路、タイマーなどが 1チップに収められています。一般的な CPU
で採用されているノイマン・アーキテクチャとは異なり、プログラムを記憶するメモリと
データを記憶するメモリを別とするハーバード・アーキテクチャを採用していて、これによって
1クロック1インストラクションの高速な動作を実現しています。

## AVR ATmega328P とは

AVR はピン数やメモリサイズの異なる幅広い製品ラインを揃えていますが、Arduino が採用している
のは ATmega328P というチップです。ATmega328P の特徴を挙げてみると以下のようになります。

- 動作速度 20MHz（動作電圧 5V のとき）
- 汎用レジスタは 32個
- 32KB のフラッシュメモリと 2KB の内臓 SRAM
- 2つの 8bit タイマ、1つの 16bit タイマ（それぞれ PWM 付き）
- 幅広いシリアルインターフェイス（SPI、USART、I2C、USI）
- ADコンバータ、アナログ・コンパレータ

## AVR エミュレータを作ろう

### 苦戦したところ..

プロジェクトを立ち上げた当初、自分はあまりに無知でマイコンがここまで多機能だと思っていませんでした。
AVR の命令セットといくつかの周辺機能をデータシート通りに実装するだけ、と思っていたのですが、
実際に取り掛かってみるとタイマやIOポートの実装をするのでも精一杯で、シリアルインターフェイス
の実装や AD コンバータは難しいと気付きました。

また、CPUコアの実装も思っていたよりもつまづくところがありました。命令セットの
仕様書にあるサイクル数と Atmel Studio シミュレータでのサイクル数が異なるケースがあったり、
暗黙のうちに周辺機能に関連したレジスタに影響があるなど、仕様の把握が難しく苦戦しました。

### つくったもの

当初の予定通りとはいきませんでしたが、最終的には最低限動作するものになりました。
成果物をまとめると次のようになります。

#### 基本構成

- AVR 命令セットの約半分（63 / 130 命令）
- 32個のレジスタファイル、SRAM、FlashMemory
- 8bit x 2個 、16bit x 1個 の PWM 付きタイマ（4つの動作モードを含む）
- IO ポートとピンの入出力

#### 動作するプログラム

- Lチカのプログラム実行と IO ポートからの出力
- 上記の WebAssembly 対応


アプリケーションとしては、
1. デバッグ用に 1命令 ずつ実行していくもの（step_by_step.rs）
2. 連続してクロックを動作させることでプログラムを実行するもの（flow.rs）
を用意しています。step_by_step.rs を実行すると画像のように Program Counter や
レジスタなどの状況を逐一確認しながら進めることができます。

![図1. step_by_step 実行イメージ](https://github.com/kazukiyoshida/nuxt-blog/blob/feature/article/src/assets/images/nuxt%2Bexpress.png "図1. step_by_step 実行イメージ")

```rust
// examples/step_by_step.rs
fn main() {
    let hex = fs::read_to_string(SAMPLE_FILE_NAME).unwrap();
    let mut avr = ATmega328P::new(Package::PDIP28);
    avr.program(hex);
    avr.initialize();
    screenshot(&avr);

    loop {
        avr.next();
        screenshot(&avr);
    }
}
```

## AVR エミュレータを作ろう

### A. メモリ

#### FlashMemory

```rust
pub struct FlashMemory {
    data: Vec<u16>,
}

impl FlashMemory {
    pub fn get(&self, a: usize) -> u16 {
        self.data[a]
    }

    pub fn set(&mut self, a: usize, v: u16) {
        self.data[a] = v;
    }

    pub fn load_hex_from_string(&mut self, hex: String) {
      ..
    }
}
```

#### SRAM

```rust
pub struct SRAM {
    data: Vec<u8>,
    pub map: &'static RegisterMap,
    pub word_map: &'static RegisterWordMap,
    pub bit_map: &'static RegisterBitMap,
}
```

マクロを使って生成します.

```rust
macro_rules! define_stationary_struct {
    ($structName: ident, $type: ty, $( $key: ident ),* ) => {
        #[derive(Debug)]
        pub struct $structName {
            $( pub $key: $type, )*
        }
    };
}

pub type RegisterBitAddr = (usize, u8);
#[rustfmt::skip]
define_stationary_struct!(
    RegisterBitMap,
    RegisterBitAddr,
    c, z, n, v, s, h, t, i,
    tov0, ocf0a, ocf0b, // Timer 0
    tov1, ocf1a, ocf1b, // Timer 1
    tov2, ocf2a, ocf2b  // Timer 2
);
```

```rust
    pub fn sp(&self) -> u16 { .. }
    pub fn push_stack(&mut self, v: u8) { .. }
    pub fn pop_stack(&mut self) -> u8 { .. }
```

### B. CPU本体

```rust
const REGISTER_MAP: RegisterMap = RegisterMap {
    sreg: 0x5f,
    sph: 0x5e,
    spl: 0x5d,

    // Timer 0 (8-bit)
    tcnt0: 0x46,
    tccr0a: 0x44,
    ...
}
```

```rust
pub struct ATmega328P {
    pc: usize,
    cycle: u64,
    instr: Option<Instr>,
    instr_func: Option<InstrFunc>,
    sram: Rc<RefCell<SRAM>>,
    flash_memory: Rc<RefCell<FlashMemory>>,
}
```


```rust
impl Iterator for ATmega328P {
    type Item = ();
    fn next(&mut self) -> Option<()> {
        // execute
        let (next_pc, next_cycle) = self.instr_func.unwrap()(
            &mut self.sram.borrow_mut(),
            &self.flash_memory.borrow(),
            self.pc,
            self.cycle,
        );

        // prepare for next
        self.pc = next_pc;
        self.cycle = next_cycle;
        let word = self.flash_memory.borrow().get(self.pc as usize);
        let (instr, instr_func) = OPCODE_TREE.with(|tree| tree.find(word));
        self.instr = Some(instr);
        self.instr_func = Some(instr_func);

        Some(())
    }
}
```

### C. 命令セット

```rust
pub enum Instr {
    ADD, ADC, ADIW, SUB, SBC, SUBI, SBCI, SBIW, DEC, COM, LD1, LD2, LD3, LDI,
    LDDY1, LDDY2, LDDY3, LDDZ1, LDDZ2, LDDZ3, LDS, OUT, IN, NOP, CALL, RCALL,
    ROL, LSL, JMP, RJMP, AND, ANDI, OR, EOR, ORI, STS, ST1, ST2, ST3, STY1,
    STY2, STY3, STZ1, STZ2, STZ3, LPM1, LPM2, LPM3, CP, CPI, CPC, CPSE, BREQ,
    BRNE, BRCS, SBIS, SEI, CLI, RET, PUSH, POP, MOV, MOVW,
}
```

```rust
thread_local! {
    #[rustfmt::skip]
    pub static OPCODE_TREE: Node = {
        let mut t: Node = Default::default();
        t.add((0b0000_1100_0000_0000, 0b1111_1100_0000_0000), Instr::ADD, &add);
        t.add((0b0001_1100_0000_0000, 0b1111_1100_0000_0000), Instr::ADC, &adc);
        t.add((0b1001_0110_0000_0000, 0b1111_1111_0000_0000), Instr::ADIW, &adiw);
        t.add((0b0001_1000_0000_0000, 0b1111_1100_0000_0000), Instr::SUB, &sub);
        t.add((0b0000_1000_0000_0000, 0b1111_1100_0000_0000), Instr::SBC, &sbc);
        t.add((0b0101_0000_0000_0000, 0b1111_0000_0000_0000), Instr::SUBI, &subi);
        t.add((0b0100_0000_0000_0000, 0b1111_0000_0000_0000), Instr::SBCI, &sbci);
        ...
    }
}
```

```rust
pub type InstrFunc = &'static dyn Fn(&mut SRAM, &FlashMemory, usize, u64) -> (usize, u64);

pub fn add(sram: &mut SRAM, flash_memory: &FlashMemory, pc: usize, cycle: u64) -> (usize, u64) {
    let (r_addr, d_addr) = flash_memory.word(pc).operand55();
    let (r, d) = sram.gets(r_addr, d_addr);
    let res = r.wrapping_add(d);
    sram.set(d_addr, res);
    sram.set_status_by_arithmetic_instruction(d, r, res);
    sram.set_bit(sram.bit_map.c, has_borrow_from_msb(r, d, res));
    (pc + 1, cycle + 1)
}

pub fn adc(sram: &mut SRAM, flash_memory: &FlashMemory, pc: usize, cycle: u64) -> (usize, u64) {
    let (r_addr, d_addr) = flash_memory.word(pc).operand55();
    let (r, d) = sram.gets(r_addr, d_addr);
    let c = sram.get_bit(sram.bit_map.c) as u8;
    let res = r.wrapping_add(d).wrapping_add(c);
    sram.set(d_addr, res);
    sram.set_status_by_arithmetic_instruction(d, r, res);
    sram.set_bit(sram.bit_map.c, has_borrow_from_msb(r, d, res));
    (pc + 1, cycle + 1)
}
```

### D. 周辺機能

### E. WebAssembly 対応

```rust
#[wasm_bindgen]
pub struct AvrMcu {
    avr: Box<dyn AVRMCU>
}

#[wasm_bindgen]
impl AvrMcu {
    pub fn new_atmega328p() -> AvrMcu {
        let avr = atmega328p::ATmega328P::new(atmega328p::Package::PDIP28);
        AvrMcu {
            avr: Box::new(avr),
        }
    }

    pub fn program(&self, hex: String) {
        self.avr.program(hex)
    }

    pub fn initialize(&mut self) {
        self.avr.initialize();
    }

    pub fn get_pins(&self) -> String {
        from_vec_bool_to_string(&self.avr.get_pins())
    }

    pub fn set_pins(&self, pins: String) {
        self.avr.set_pins(from_string_to_vec_bool(&pins));
    }
}
```

## 終わりに
