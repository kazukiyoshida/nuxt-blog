電子工作を気軽に楽しめる [Arduino](https://www.arduino.cc/) というマイコンボードをご存知でしょうか。
ボードとパーツを用意して Arduino 言語でプログラミングをすることで、
初心者でも簡単にセンサーの制御やモーターの駆動などを楽しめるようにした人気のプラットフォームです。

今回はその Arduino のマイコンとして採用されている Atmel AVR マイクロコントローラの
エミュレータを Rust で実装した話を書いてみます。

AVR マイコンは非常に多機能で、最終的には**マイコンのエミュレータ**を完全な形で実装することは
難しいと気付いたのですが、その過程の中で最低限動作するエミュレータができました。
Rust で実装する CPU エミュレータに興味がある方、Arduino の CPU の詳細に興味がある方
の参考になれば幸いです。

ソースコードは[こちら](https://github.com/kazukiyoshida/avr-emulator)に公開しています。  
言語は Rust 1.46、動作環境は macOS Catalina 10.15.7 です。

## AVR マイコンとは

AVR はアトメル社が開発し、現在は Microchip社が製造・販売している RISC ベース 8bit 
マイクロコントローラです。CPU、メモリ、IOポート、クロック発振回路、タイマーなどが 
1チップに収められています。一般的な CPU で採用されているノイマン・アーキテクチャとは異なり、
プログラムを記憶するメモリとデータを記憶するメモリを別とするハーバード・アーキテクチャを採用していて、
これによって1クロック1インストラクションの高速な動作を実現しています。

物理的なチップに加えて、AVR マイコンの動作をシミュレーションするツールも Microchip 社から
公式に提供されています。以前は Atmel Studio という名前でしたが、2021年現在は
[Microchip Studio](https://www.microchip.com/en-us/development-tools-tools-and-software/microchip-studio-for-avr-and-sam-devices)
という名称になっています。このシミュレータを使うことでアセンブラ単位での実行やメモリの
値を確認することができ、今回はこれを正としてエミュレータを実装しました。

## AVR ATmega328P とは

AVR はピン数やメモリサイズの異なる幅広い製品ラインを揃えていますが、Arduino が採用している
のは ATmega328P というチップです。ATmega328P の特徴を挙げてみると以下のようになります。

- 動作速度 20MHz（動作電圧 5V のとき）
- 32KB のフラッシュメモリと 2KB の内臓 SRAM
- 2つの 8bit タイマ、1つの 16bit タイマ（それぞれ PWM 付き）
- 幅広いシリアルインターフェイス（SPI、USART、I2C、USI）
- ADコンバータ、アナログ・コンパレータ

![ATmega328p](https://github.com/kazukiyoshida/nuxt-blog/blob/feature/avr-emulator/src/assets/images/20210118/atmega328p.jpg "ATmega328p")

## AVR エミュレータの実装目標

### 当初の目標

プロジェクトを立ち上げた当初、自分はあまりに無知でマイコンがここまで多機能だと思っていませんでした。
AVR の命令セットといくつかの周辺機能をデータシート通りに実装するだけ、と思っていたのですが、
実際に取り掛かってみるとタイマやIOポートの実装をするのでも精一杯で、シリアルインターフェイス
の実装や AD コンバータは難しいと気付きました。

また、CPUコアの実装も思っていたよりもつまづくところがありました。命令セットの
仕様書にあるサイクル数と Atmel Studio シミュレータでのサイクル数が異なるケースがあったり、
暗黙のうちに周辺機能に関連したレジスタに影響があるなど、仕様の把握が難しく苦戦しました。

結果としてプロジェクトの時間が確保できなくなったため、現時点における成果物を公開しています。

### つくったもの

当初の予定通りとはいきませんでしたが、最終的には最低限動作するものになりました。
成果物をまとめると次のようになります。

#### 基本構成

- AVR 命令セットの約半分（63 / 130 命令）
- 32個のレジスタファイル、SRAM、FlashMemory
- 8bit x 2個 、16bit x 1個 の PWM 付きタイマ（4つの動作モードを含む）
- IO ポートとピンの入出力

#### エミュレータにプログラムする実行ファイル

- Atmel Studio でコンパイルした Lチカ のプログラム


#### 実装したアプリケーション

- デバッグ用に 1命令 ずつ実行していくもの（step_by_step.rs）
- 連続してクロックを動作させることでプログラムを実行するもの（flow.rs）
- 上記wo WebAssembly として実行させるもの

step_by_step.rs を実行すると画像のように Program Counter や
レジスタなどの状況を逐一確認しながら進めることができます。

![図1. step_by_step 実行イメージ](https://github.com/kazukiyoshida/nuxt-blog/blob/feature/avr-emulator/src/assets/images/20210118/step_image.png "図1. step_by_step 実行イメージ")

## AVR エミュレータを作ろう

### A. メモリ

#### FlashMemory

AVR の FlashMemory は 16 bit のシンプルな線形メモリで、ここにブートローダやプログラムが書き込まれます。
今回はこれを u16 のベクタで表現します。固定長の配列`[u16; N]`で表現することも
できますが、ATmega328P のメモリサイズに限定したくなかったのでベクタを使っています。

メモリに必要な機能としては、値を読み出す関数 、値をセットする関数 、
HEXファイルを書き込む（プログラムする）関数、などが必要となるので実装します。

Intel HEX の仕様については[Wikipedia](https://ja.wikipedia.org/wiki/Intel_HEX)が詳しいです。
レコードタイプがデータとなっている行に16進数でプログラムが並んでいるので、
1word（16bit）にあたる4文字を取得して、リトルエンディアンでメモリに展開しています。
つまり HEX ファイルで "...ABCD..." というデータがあれば、FlashMemory の1アドレスには "CDAB" と書き込まれます。

```rust
pub struct FlashMemory {
    data: Vec<u16>,
}

impl FlashMemory {
    // 番地を指定して値を読み出す
    pub fn get(&self, a: usize) -> u16 { self.data[a] }

    // 番地を指定して値を更新する
    pub fn set(&mut self, a: usize, v: u16) { self.data[a] = v; }

    // Intel HEX 形式の実行ファイルに相当する文字列からプログラムをメモリに展開する
    pub fn load_hex_from_string(&mut self, hex: String) { ..  }
}
```

#### SRAM

AVR のデータ・メモリ・スペースは 8bit で構成されています。
今回はレジスタファイル、I/Oレジスタ、内部SRAM をまとめて SRAM として宣言しました。
そのため 0x00 ~ 0x1f 番地（0 ~ 31）がレジスタファイル、0x20 ~ 0x5f 番地（32 ~ 96）
が I/Oレジスタとなっています。

AVR のレジスタ名称は共通化されている（SREG、SPH、SPL など）のですが、
具体的なメモリ番地は製品のデータシートを読む必要があります。
今回は ATmega328P に特化させず、一般的な AVR マイコンに対応した SRAM として実装したかったので、
このレジスタマップは後から設定できるようにしました。

```rust
pub struct SRAM {
    data: Vec<u8>,
    pub map: &'static RegisterMap,            // レジスタマップを設定できるようにテーブルを用意
    pub word_map: &'static RegisterWordMap,   // 1word 単位でのレジスタマップの設定テーブル
    pub bit_map: &'static RegisterBitMap,     // 1bit 単位でのレジスタマップの設定テーブル
}

// レジスタマップを設定するためのテーブル
struct RegisterMap {
    sreg: usize,  // ステータス・レジスタの番地
    sph: usize,   // Stack Pointer High
    spl: usize,   // Stack Pointer Low
    portd: usize, // ポートD の PORTx レジスタ
    ddrd: usize,  // ポートD の データ・ディレクション・レジスタ
    pind: usize,  // ポートD の PINx レジスタ
    ..            // 他にもたくさん..
}
```

上記のように RegisterMap は繰り返しの記述が多くなったので、独自のマクロで定義を簡素化しました。
下のマクロを実行すると、上で記述した RegisterMap の宣言が展開されます。

```rust
// 定型的な構造体の宣言を簡素化する独自マクロ
define_stationary_struct!(
    RegisterMap,   // 定義したい構造体の名前
    usize,         // 値の型
    sreg, sph, spl, portd, ddrd, pind, ucsr0a, ucsr0b, ucsr0c,              // 構造体のキー（レジスタの名前）を列挙
    portc, ddrc, pinc, portb, ddrb, pinb, ramend, mcusr, twsr, twar, twdr,
    ...
);
```

プログラムが実行されると SRAM の RAMEND から 0x0000 に向けてスタックが伸びていきます。
スタック・ポインタを取得する関数やスタックの push・pop を実行する関数なども用意します。

```rust
impl SRAM {
    pub fn sp(&self) -> u16 { .. }
    pub fn push_stack(&mut self, v: u8) { .. }
    pub fn pop_stack(&mut self) -> u8 { .. }
}
```

### B. CPU本体

#### AVRマイコン トレイト

今回は ATmega328P の実装しかできませんでしたが、当初は AVR マイコンの一般的な実装を行いたかったので
AVR マイコンとしての振る舞いをトレイトとして用意しました。用意した機能は、(1) プログラムの書き込み、
(2) CPUの初期化、(3, 4) IO ポートの読み書き、です。

```rust
pub trait AVRMCU {
    // HEX 形式のプログラムを FlashMemory に書き込む
    fn program(&self, hex: String);

    // PC, SP, SREG など CPU のステータスを初期化する
    fn initialize(&mut self);

    // IO ポートの値を読み取る
    fn get_pins(&self) -> Vec<bool>;

    // IO ポートに値を入力する
    fn set_pins(&self, pins: Vec<bool>);
}
```

今回はクロックを進める振る舞いは AVRMCU トレイトには含めず、代わりに Iterator トレイトを実装する方針としました。
これについては ATmega328P の実装の際に見ていきます。

#### ATmega328P

ATmega328P の具体的な実装に入ります。ATmega328P のコアは FlashMemory、SRAM に
加えて、Program Counter（PC）、現在のサイクル数、次回実行予定のインストラクション
を保持する構造体として定義しました。

```rust
pub struct ATmega328P {
    pc: usize,                              // Program Counter
    cycle: u64,                             // 実行サイクル数
    instr: Option<Instr>,                   // （次の）命令
    instr_func: Option<InstrFunc>,          // （次の）命令に対応する関数
    sram: Rc<RefCell<SRAM>>,                // SRAM
    flash_memory: Rc<RefCell<FlashMemory>>, // FlashMemory
}
```

また前述の通り SRAM は AVR に一般的な実装としているので、ATmega328P の実装の際に
そのレジスタマップを[データシート](https://avr.jp/user/DS/PDF/mega328P.pdf)通りに宣言していきます。

```rust
const REGISTER_MAP: RegisterMap = RegisterMap {
    sreg: 0x5f,
    sph: 0x5e,
    spl: 0x5d,

    // Timer 0 (8-bit)
    tcnt0: 0x46,
    tccr0a: 0x44,
    ...
}
```

ATmega328P には Iterator を実装し、next 関数をコールすることでインストラクション
が実行されるようにしました。PC が示す 1word から、AVR インストラクションをデコードする
必要がありますが、これを実現するために後述する命令セットツリー`OPCODE_TREE`を用いています。

```rust
impl Iterator for ATmega328P {
    type Item = ();

    fn next(&mut self) -> Option<()> {
        // *** インストラクションの実行
        let (next_pc, next_cycle) = self.instr_func.unwrap()(
            &mut self.sram.borrow_mut(),
            &self.flash_memory.borrow(),
            self.pc,
            self.cycle,
        );

        // *** 次のインストラクションに向けた準備
        self.pc = next_pc;       // PC を再設定
        self.cycle = next_cycle; // サイクル数も更新

        // FlashMemory から PC が示す 1word のプログラムを取得
        let word = self.flash_memory.borrow().get(self.pc as usize);

        // 取得した 1word がどの AVR インストラクションに対応するのか検索する
        let (instr, instr_func) = OPCODE_TREE.with(|tree| tree.find(word));
        self.instr = Some(instr);
        self.instr_func = Some(instr_func);

        Some(())
    }
}
```

### C. 命令セット

AVR 命令セットは全130命令ありますが、そのうち半分程度を実装しました。
各命令に対応した関数 InstrFunc を用意し、これがメモリを更新したり、
次回の Program Counter とサイクル数を返すようにしています。

今回は FlashMemory, SRAM としてトレイトオブジェクトを使用して動的ディスパッチをさせていますが、
これは ATmega328P 以外の実装を増やしていった場合にエミュレータの実行バイナリが肥大化
するのを防ぐためでした。

```rust
// 命令セット Enum
pub enum Instr {
    ADD, ADC, ADIW, SUB, SBC, SUBI, SBCI, SBIW, DEC, COM, LD1, LD2, LD3, LDI,
    LDDY1, LDDY2, LDDY3, LDDZ1, LDDZ2, LDDZ3, LDS, OUT, IN, NOP, CALL, RCALL,
    ...
}

// インストラクション関数の型
pub type InstrFunc = &'static dyn Fn(&mut SRAM, &FlashMemory, usize, u64) -> (usize, u64);

// ADD 命令のインストラクション関数
pub fn add(sram: &mut SRAM, flash_memory: &FlashMemory, pc: usize, cycle: u64) -> (usize, u64) {
    let (r_addr, d_addr) = flash_memory.word(pc).operand55();
    let (r, d) = sram.gets(r_addr, d_addr);
    let res = r.wrapping_add(d);
    sram.set(d_addr, res);
    sram.set_status_by_arithmetic_instruction(d, r, res);
    sram.set_bit(sram.bit_map.c, has_borrow_from_msb(r, d, res));
    (pc + 1, cycle + 1)
}
```

PC が示す 1word のプログラムから AVR インストラクションをデコードするために、
オペコードと命令セットのツリー OPCODE_TREE を構築しています。
検索したい 1word の命令のビット列の左端から見ていき、ツリーを辿っていくと命令にたどり着くようになっています。

OPCODE_TREE は AVR 命令のアドレッシングモードも考慮する必要があります。
[AVR Instruction Set Manual](http://ww1.microchip.com/downloads/en/devicedoc/atmel-0856-avr-instruction-set-manual.pdf)
を見ると、例えば ADD 命令は

- `0000_11rd_dddd_rrrr`

と定義されています。この場合、先頭 6bit がオペコードとなるのでこれを 

- `1111_1100_0000_0000`（マスク）
- `0000_1100_0000_0000`（オペコード）

のペアとして表現しています。
ツリーはアプリケーション起動時に static なデータとして構築しています。
（lazy_static で定義せず thread local に宣言している理由は忘れました...）

```rust
thread_local! {
    pub static OPCODE_TREE: Node = {
        let mut t: Node = Default::default();
        t.add((0b0000_1100_0000_0000, 0b1111_1100_0000_0000), Instr::ADD, &add);
        t.add((0b0001_1100_0000_0000, 0b1111_1100_0000_0000), Instr::ADC, &adc);
        t.add((0b1001_0110_0000_0000, 0b1111_1111_0000_0000), Instr::ADIW, &adiw);
        t.add((0b0001_1000_0000_0000, 0b1111_1100_0000_0000), Instr::SUB, &sub);
```

### D. 周辺機能

#### 8bit/16bit タイマ・カウンタ

このプロジェクトで最も苦戦したのがタイマ・カウンタの実装でした。
AVR のタイマ・カウンタは4つの動作モードがあり、コントロール・レジスタを
セットすることでプリスケーリングも調整が可能で、さらに 3つ用意されているタイマは
それぞれ仕様が異なりました。1サイクルでもずれると、ズレは大きくなっていくので
ここを出来るだけ合わせることに時間がかかりました。

#### IOポート


### E. WebAssembly 対応

今回作ったエミュレータはブラウザで動作させたかったので WebAssembly 対応をしました。
AVRMCU トレイトで定義した振る舞いが wasm での IF としてそのまま残されています。

```rust
#[wasm_bindgen]
pub struct AvrMcu {
    avr: Box<dyn AVRMCU>
}

#[wasm_bindgen]
impl AvrMcu {
    pub fn new_atmega328p() -> AvrMcu {
        let avr = atmega328p::ATmega328P::new(atmega328p::Package::PDIP28);
        AvrMcu {
            avr: Box::new(avr),
        }
    }

    pub fn program(&self, hex: String) {
        self.avr.program(hex)
    }

    pub fn initialize(&mut self) {
        self.avr.initialize();
    }

    pub fn get_pins(&self) -> String {
        from_vec_bool_to_string(&self.avr.get_pins())
    }

    pub fn set_pins(&self, pins: String) {
        self.avr.set_pins(from_string_to_vec_bool(&pins));
    }
}
```

## 終わりに
